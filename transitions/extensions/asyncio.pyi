from ..core import Condition as Condition, Event as Event, EventData as EventData, Machine as Machine, MachineError as MachineError, State as State, Transition as Transition, listify as listify
from .nesting import HierarchicalMachine as HierarchicalMachine, NestedEvent as NestedEvent, NestedState as NestedState, NestedTransition as NestedTransition, _resolve_order as _resolve_order
from typing import Any, Optional, List, Type, Dict, Deque, Callable, Union
from asyncio import Task
from contextvars import ContextVar

from ..core import StateIdentifier, CallbacksArg, CallbackList
from .nesting import StateTree

_LOGGER: Any

class AsyncState(State):
    async def enter(self, event_data: EventData) -> None: ...
    async def exit(self, event_data: EventData) -> None: ...

class NestedAsyncState(NestedState, AsyncState):
    _scope: Any
    async def scoped_enter(self, event_data: EventData, scope: Optional[List[str]] = ...) -> None: ...
    async def scoped_exit(self, event_data: EventData, scope: Optional[List[str]] = ...) -> None: ...

class AsyncCondition(Condition):
    async def check(self, event_data: EventData) -> bool: ...

class AsyncTransition(Transition):
    condition_cls: Type[AsyncCondition]
    async def _eval_conditions(self, event_data: EventData) -> bool: ...
    async def execute(self, event_data: EventData) -> bool: ...
    async def _change_state(self, event_data: EventData) -> None: ...

class NestedAsyncTransition(AsyncTransition, NestedTransition):
    async def _change_state(self, event_data: EventData) -> None: ...

class AsyncEvent(Event):
    async def trigger(self, model: object, *args, **kwargs) -> bool: ...
    async def _trigger(self, model: object, *args, **kwargs) -> bool: ...
    async def _process(self, event_data: EventData) -> bool: ...

class NestedAsyncEvent(NestedEvent):
    async def trigger(self, _model: object, _machine: HierarchicalAsyncMachine, *args, **kwargs) -> bool: ...
    async def _trigger(self, _model: object, _machine: HierarchicalAsyncMachine, *args, **kwargs) -> bool: ...
    async def _process(self, event_data: EventData) -> bool: ...

class AsyncMachine(Machine):
    state_cls: Type[AsyncEvent]
    transition_cls: Type[AsyncTransition]
    event_cls: Type[AsyncEvent]
    async_tasks: Dict[int, List[Task]]
    protected_tasks: List[Task]
    current_context: ContextVar
    _transition_queue_dict: Dict[int, Deque[Callable]]
    def __init__(self, *args, **kwargs) -> None: ...
    def add_model(self, model: Union[Union[Machine.self_literal, object], List[Union[Machine.self_literal, object]]],
                  initial: StateIdentifier = ...) -> None: ...
    async def dispatch(self, trigger: str, *args, **kwargs) -> bool: ...
    async def callbacks(self, funcs: List[Union[str, Callable]], event_data: EventData) -> None: ...
    async def callback(self, func: Union[str, Callable], event_data: EventData) -> None: ...
    @staticmethod
    async def await_all(callables: List[Callable]) -> List: ...
    async def switch_model_context(self, model: object) -> None: ...
    async def process_context(self, func: Callable, model: object) -> bool: ...
    def remove_model(self, model: object) -> None: ...
    async def _process(self, trigger: Callable, model: object) -> bool: ...

class HierarchicalAsyncMachine(HierarchicalMachine, AsyncMachine):
    state_cls: Type[NestedAsyncState]
    transition_cls: Type[NestedAsyncTransition]
    event_cls: Type[NestedAsyncEvent]
    async def trigger_event(self, _model: object, _trigger: str, *args, **kwargs): ...
    async def _trigger_event(self, _model: object, _trigger: str, _state_tree: Optional[StateTree],
                             *args, **kwargs): ...

class AsyncTimeout(AsyncState):
    dynamic_methods: List[str]
    timeout: float
    _on_timeout: CallbacksArg
    runner: Dict[int, Task]
    def __init__(self, *args, **kwargs) -> None: ...
    async def enter(self, event_data: EventData) -> None: ...
    async def exit(self, event_data: EventData) -> None: ...
    def create_timer(self, event_data: EventData): ...
    async def _process_timeout(self, event_data: EventData) -> None: ...
    @property
    def on_timeout(self) -> CallbackList: ...
    @on_timeout.setter
    def on_timeout(self, value: CallbacksArg) -> None: ...

class _DictionaryMock(dict):
    _value: Any
    def __init__(self, item) -> None: ...
    def __setitem__(self, key: Any, item: Any) -> None: ...
    def __getitem__(self, key: Any) -> Any: ...
    def __repr__(self) -> str: ...
